interface CreatePROptions {
  accessToken: string;
  owner: string;
  repo: string;
  baseBranch?: string;
  branchName?: string;
  files: Array<{ path: string; content: string }>;
}

interface GitHubApiResponse {
  object?: { sha: string };
  sha?: string;
  html_url?: string;
  message?: string;
}

async function githubApi(
  url: string,
  accessToken: string,
  options: RequestInit = {}
): Promise<GitHubApiResponse> {
  const response = await fetch(`https://api.github.com${url}`, {
    ...options,
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      "Content-Type": "application/json",
      ...options.headers,
    },
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GitHub API error (${response.status}): ${error}`);
  }

  return response.json();
}

export async function getRepoTree(
  accessToken: string,
  owner: string,
  repo: string,
  branch: string = "main"
): Promise<string[]> {
  try {
    const data = await githubApi(
      `/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`,
      accessToken
    );

    if (!Array.isArray((data as { tree?: unknown[] }).tree)) {
      return [];
    }

    return (data as { tree: Array<{ type: string; path: string }> }).tree
      .filter((item) => item.type === "blob")
      .map((item) => item.path);
  } catch (error) {
    console.error("Failed to get repo tree:", error);
    throw error;
  }
}

export async function getFileContent(
  accessToken: string,
  owner: string,
  repo: string,
  path: string,
  branch: string = "main"
): Promise<string> {
  const data = await githubApi(
    `/repos/${owner}/${repo}/contents/${path}?ref=${branch}`,
    accessToken
  );

  const content = (data as { content?: string }).content;
  if (!content) {
    throw new Error(`No content found for ${path}`);
  }

  // GitHub returns base64 encoded content
  return Buffer.from(content, "base64").toString("utf-8");
}

export async function getMultipleFileContents(
  accessToken: string,
  owner: string,
  repo: string,
  paths: string[],
  branch: string = "main"
): Promise<Record<string, string>> {
  const contents: Record<string, string> = {};

  // Fetch files in parallel with concurrency limit
  const CONCURRENCY = 5;
  for (let i = 0; i < paths.length; i += CONCURRENCY) {
    const batch = paths.slice(i, i + CONCURRENCY);
    const results = await Promise.allSettled(
      batch.map((path) => getFileContent(accessToken, owner, repo, path, branch))
    );

    results.forEach((result, index) => {
      if (result.status === "fulfilled") {
        contents[batch[index]] = result.value;
      } else {
        console.warn(`Failed to fetch ${batch[index]}:`, result.reason);
      }
    });
  }

  return contents;
}

export async function createPR({
  accessToken,
  owner,
  repo,
  baseBranch = "main",
  branchName = "brev-setup",
  files,
}: CreatePROptions): Promise<string> {
  // Get the SHA of the base branch
  const baseRef = await githubApi(
    `/repos/${owner}/${repo}/git/ref/heads/${baseBranch}`,
    accessToken
  );

  if (!baseRef.object?.sha) {
    throw new Error(`Could not get SHA for branch ${baseBranch}`);
  }

  const baseSha = baseRef.object.sha;

  // Create a new branch
  const timestamp = Date.now();
  const uniqueBranchName = `${branchName}-${timestamp}`;

  try {
    await githubApi(`/repos/${owner}/${repo}/git/refs`, accessToken, {
      method: "POST",
      body: JSON.stringify({
        ref: `refs/heads/${uniqueBranchName}`,
        sha: baseSha,
      }),
    });
  } catch (error) {
    // Branch might already exist, try with a different name
    console.warn("Branch creation failed, might already exist:", error);
    throw error;
  }

  // Create/update each file
  for (const file of files) {
    await githubApi(`/repos/${owner}/${repo}/contents/${file.path}`, accessToken, {
      method: "PUT",
      body: JSON.stringify({
        message: `Add ${file.path} for Brev.dev environment`,
        content: Buffer.from(file.content).toString("base64"),
        branch: uniqueBranchName,
      }),
    });
  }

  // Create the pull request
  const pr = await githubApi(`/repos/${owner}/${repo}/pulls`, accessToken, {
    method: "POST",
    body: JSON.stringify({
      title: "ðŸš€ Configure Brev.dev GPU Environment",
      head: uniqueBranchName,
      base: baseBranch,
      body: `## Brev Doctor Configuration

This PR was automatically generated by **Brev Doctor** to configure your GPU development environment.

### Files Added:
${files.map((f) => `- \`${f.path}\``).join("\n")}

### Next Steps:
1. Review the generated configuration files
2. Merge this PR
3. Visit [brev.dev](https://brev.dev) to launch your GPU instance

---
*Generated by Brev Doctor*`,
    }),
  });

  if (!pr.html_url) {
    throw new Error("Failed to create PR - no URL returned");
  }

  return pr.html_url;
}

export interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  owner: {
    login: string;
    avatar_url: string;
  };
  description: string | null;
  private: boolean;
  html_url: string;
  updated_at: string;
  language: string | null;
  stargazers_count: number;
}

export async function getUserRepos(
  accessToken: string
): Promise<GitHubRepo[]> {
  try {
    const response = await fetch("https://api.github.com/user/repos?per_page=100&sort=updated", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`GitHub API error (${response.status}): ${error}`);
    }

    return response.json();
  } catch (error) {
    console.error("Failed to fetch user repos:", error);
    throw error;
  }
}

export function parseRepoUrl(url: string): { owner: string; repo: string } | null {
  // Handle various GitHub URL formats
  const patterns = [
    /github\.com[/:]([^/]+)\/([^/.]+)/,
    /^([^/]+)\/([^/]+)$/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return {
        owner: match[1],
        repo: match[2].replace(/\.git$/, ""),
      };
    }
  }

  return null;
}

